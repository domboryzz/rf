<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Rainforest Alliance Scanner</title>
  <style>
    #preview { width: 100%; max-width: 480px; border-radius: 8px; }
    #status { margin-top: 8px; font-family: sans-serif; }
    #controls { margin: 10px 0; display: flex; gap: 8px; flex-wrap: wrap; }
    button, select { padding: 6px 10px; }
    .ok { color: #0a7; } .warn { color: #d80; } .err { color: #c22; }
    #result { text-align: center; font-size: 20px; margin-top: 10px; font-weight: bold; }
    #explanation { text-align: center; margin-top: 5px; font-size: 16px; color: #333; }
    .yes { color: green; } .no { color: red; }
  </style>
</head>
<body>
  <h1 style="text-align:center;">Rainforest Alliance Checker</h1>
  <video id="preview" autoplay muted playsinline></video>
  <div id="controls">
    <select id="cameraSelect"></select>
    <button id="torchBtn">Toggle torch</button>
    <button id="pauseBtn">Pause</button>
  </div>
  <div id="status"></div>
  <div id="barcode"></div>
  <div id="result"></div>
  <div id="explanation"></div>

  <script src="https://unpkg.com/@zxing/browser@latest"></script>
  <script>
  (async () => {
    const video = document.getElementById('preview');
    const statusEl = document.getElementById('status');
    const barcodeEl = document.getElementById('barcode');
    const resultEl = document.getElementById('result');
    const explanationEl = document.getElementById('explanation');
    const cameraSelect = document.getElementById('cameraSelect');
    const torchBtn = document.getElementById('torchBtn');
    const pauseBtn = document.getElementById('pauseBtn');

    const { BrowserMultiFormatReader, DecodeHintType, BarcodeFormat } = ZXingBrowser;

    const hints = new Map();
    hints.set(DecodeHintType.POSSIBLE_FORMATS, [
      BarcodeFormat.EAN_13, BarcodeFormat.CODE_128, BarcodeFormat.EAN_8, BarcodeFormat.UPC_A
    ]);
    hints.set(DecodeHintType.TRY_HARDER, true);

    const reader = new BrowserMultiFormatReader(hints);
    let currentStreamTrack, isPaused=false, torchOn=false;
    const REQUIRED_MATCHES = 3, WINDOW_MS=1200;
    let recent=[];

    function setStatus(msg, cls='') { statusEl.className = cls; statusEl.textContent = msg; }
    function setResult(text) { resultEl.textContent = text ? `Decoded: ${text}` : ''; }

    async function askGemini(brandAndName) {
      const prompt = `Czy marka "${brandAndName}" ma produkty z certyfikatem Rainforest Alliance? 
Sprawdź zdjęcia różnych produktów tej marki i informacje w internecie. 
Odpowiedz tylko "tak" albo "nie". 
Jeśli odpowiesz "tak", krótko wyjaśnij dlaczego – np. znalazłeś dowód na stronie internetowej, zdjęcia produktu, opis producenta itp.`;

      try {
        const response = await fetch(
          "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=AIzaSyDU9GAFN0h4c91k11Cf2bKhQ--SoNrKj0g",
          { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ contents:[{ parts:[{ text: prompt }] }] }) }
        );
        const data = await response.json();
        const answer = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim().toLowerCase();

        if(!answer){ resultEl.textContent="Brak odpowiedzi od Gemini."; return; }
        if(answer.startsWith("tak")){ resultEl.innerHTML=`<span class="yes">TAK</span>`; explanationEl.textContent=answer.replace(/^tak[, ]*/i,""); }
        else if(answer.startsWith("nie")){ resultEl.innerHTML=`<span class="no">NIE</span>`; explanationEl.textContent=""; }
        else{ resultEl.textContent="Niejasna odpowiedź."; explanationEl.textContent=answer; }
      } catch(e){ console.error(e); resultEl.textContent="Błąd podczas łączenia z Gemini."; }
    }

    async function getProductInfo(barcode) {
      barcodeEl.textContent=`Barcode: ${barcode}`;
      try {
        const response = await fetch(`https://world.openfoodfacts.org/api/v0/product/${barcode}.json`);
        const data = await response.json();
        if(!data.product){ resultEl.innerHTML=`<span class="no">Produkt nie znaleziony</span>`; explanationEl.textContent=""; return; }
        const brand = data.product.brands||"", name = data.product.product_name||"";
        const combined = `${brand} ${name}`.trim();
        if(!combined){ resultEl.innerHTML=`<span class="no">Brak informacji o produkcie</span>`; explanationEl.textContent=""; return; }
        askGemini(combined);
      } catch(e){ console.error(e); resultEl.textContent="Błąd podczas pobierania informacji z OpenFoodFacts."; }
    }

    async function stopStream() {
      if(currentStreamTrack){ try{ await currentStreamTrack.applyConstraints({ advanced:[{ torch:false }] }); }catch{} currentStreamTrack.stop(); currentStreamTrack=null; }
      await reader.stopContinuousDecode();
    }

    async function start(deviceId){
      await stopStream();
      setStatus('Starting camera...','warn');

      const constraints = {
        audio:false,
        video:{ deviceId: deviceId?{exact:deviceId}:undefined, facingMode: deviceId?undefined:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720} }
      };

      await reader.decodeFromConstraints(constraints, video, (res, err)=>{
        if(!currentStreamTrack){ const s = video.srcObject; if(s) currentStreamTrack = s.getVideoTracks()[0]; }

        if(res){
          const now=Date.now();
          recent.push({ text: res.getText(), ts: now });
          recent = recent.filter(r=>now-r.ts<=WINDOW_MS);
          const counts = recent.reduce((m,r)=>(m[r.text]=(m[r.text]||0)+1,m),{});
          const bestText = Object.keys(counts).sort((a,b)=>counts[b]-counts[a])[0];
          const bestCount = counts[bestText];
          setStatus(`Reading... (${bestCount}/${REQUIRED_MATCHES})`,'warn');
          if(bestCount>=REQUIRED_MATCHES){ setStatus('Locked result','ok'); getProductInfo(bestText); }
        }
      });

      setStatus('Point camera at barcode','ok');
    }

    async function listCameras(){
      const devices = await BrowserMultiFormatReader.listVideoInputDevices();
      cameraSelect.innerHTML='';
      devices.forEach((d,i)=>{ const opt=document.createElement('option'); opt.value=d.deviceId; opt.textContent=d.label||`Camera ${i+1}`; cameraSelect.appendChild(opt); });
      const env = devices.find(d=>/back|rear|environment/i.test(d.label));
      if(env) cameraSelect.value=env.deviceId;
    }

    cameraSelect.addEventListener('change',()=>start(cameraSelect.value));
    torchBtn.addEventListener('click', async ()=>{
      if(!currentStreamTrack){ setStatus('No camera track','err'); return; }
      const caps=currentStreamTrack.getCapabilities?.()||{};
      if(!('torch' in caps)){ setStatus('Torch not supported','err'); return; }
      torchOn = !torchOn;
      try{ await currentStreamTrack.applyConstraints({ advanced:[{ torch: torchOn }] }); setStatus(`Torch ${torchOn?'on':'off'}`,'ok'); }catch{ setStatus('Failed to toggle torch','err'); }
    });
    pauseBtn.addEventListener('click',()=>{ if(isPaused){ isPaused=false; pauseBtn.textContent='Pause'; start(cameraSelect.value); } else{ isPaused=true; pauseBtn.textContent='Resume'; reader.stopContinuousDecode(); setStatus('Paused','warn'); } });

    try{ await listCameras(); await start(cameraSelect.value); }catch(e){ setStatus('Camera access failed. Check permissions.','err'); console.error(e); }
  })();
  </script>
</body>
</html>
